#!/usr/bin/env bash

set -o errexit  # Abort on nonzero exit code.
set -o noglob   # Disable globbing.
set +o xtrace   # Disable debug mode.
set -o pipefail # Don't hide errors within pipes.

# Current version.
version="3.0"

# Assign the path to the config file to the variable '${config}'.
config_path="${HOME}/.config/bashpass"
config="${config_path}/bashpass.conf"

# Detect the config file.
if [[ ! -f ${config} ]]; then
    printf '\n'
    printf 'An error occurred: config file not found.'
    printf '\n'
    exit 2
fi

# Simple function to get the setting '${1}' from the config file.
# This basically replaces the '$(grep "setting" "${config}" | cut -d" " -f2)'.
# It's also pure bash, which means that no sub shells are used.
get_setting() {
    while read -r;
    do
        if [[ "${REPLY}" =~ ^${1} ]]; then
            printf '%s' "${REPLY#*: }"
            break
        fi
    done < "${config}"
}

# Get the necessary configurations from the configuration file.
# '|| :' To prevent the script from exiting if the variable is not found
# (especially needed for the '${configured_email} variable').
configured_email="$(get_setting 'email')" || :
configured_key_id="$(get_setting 'keyID')" || :
configured_pass_location="${HOME}/$(get_setting 'location')" || :
configured_timer="$(get_setting 'timer')" || :
configured_pass_length="$(get_setting 'length')" || :
configured_git_repo="$(get_setting 'gitRepo')" || :

# Print error message to stderr, and exit with the given exit status.
error_out() {
    printf '\n'
    printf 'An error occurred: %s' "${1}" >&2
    printf '\n'
    exit "${2}"
}

# Surprisingly, `sleep` is an external program and not a Bash built-in.
# So it is possible that it is not installed on a system, although it is very unlikely.
# We can use `read` to replace the `sleep` command.
sleep() {
    read -rt "${1}" <> <(:) || :
}

# Wrapper for `command -v` to avoid spamming '> /dev/null'.
# It also protects against user aliasses and functions.
has() {
    command=$(command -v "${1}") 2> /dev/null || error_out "${1} is required" "127"
    [[ -x ${command} ]] || error_out "${1} is not an executable" "1"
}

# Return all possible options/usages of BashPass.
help() {
    printf '%s' "\
BashPass version: ${version}
A password manager written in Bash.

bashpass [option] [name]                            - Basic command structure.

Options:
--help      or -h                                   - show this help message.
--version   or -v                                   - show the version number
--list      or -l                                   - list all password.
--add       or -a                            [name] - add a password.
--update    or -u                            [name] - update a password.
--delete    or -d                            [name] - delete a password.
--show      or -s                            [name] - show a password.
--copy      or -c                            [name] - copy a password to the clipboard.
--sync      or -S    [synchronize command]          - synchronize password(s) with a git repository.

synchronize command:
    upload           - Upload local password(s) to a remote repository.
    download         - Download password(s) from a remote repository.
"
}

# Return the current verion of BashPass.
version() {
    printf 'BashPass version: %s' "${version}"
    printf '\n'
}

# Function to ask for a name.
set_name() {
    pass_name="${1}"
    functionality="${2}"

    if [[ -z "${pass_name}" ]]; then
        printf 'Enter the name of the password you want to %s: ' "${functionality}"
        read -r pass_name
    fi
}

# Check whether the given password exists.
check_password_exists() {
    pass_name="${1}"

    [[ -f "${configured_pass_location}/${pass_name}.gpg" ]] || \
        error_out "password '${pass_name}' doesn't exist." "1"
}

# Ask the user whether he would like to generate a password or to enter one himself.
set_password() {
    printf 'Do you want to generate a password [Y/n]: '
    read -r random

    case "${random}" in
        [Nn])
            printf 'Enter a password for %s: ' "${pass_name}"
            read -rs password1
            printf '\n'

            [[ -z "${password1}" ]] && error_out "the password cannot be empty." "1"

            printf 'Retype the password for %s: ' "${pass_name}"
            read -rs password2
            printf '\n'

            while [[ "${password1}" != "${password2}" ]]; do
                printf 'Passwords didn'\''t match, please try again: '
                read -rs password2
                printf '\n'
            done

            password=${password1}
            ;;
        *)
            printf 'Give the length of the password (Default: %s): ' "${configured_pass_length}"
            read -r pass_length

            [[ -z ${pass_length} ]] && pass_length=${configured_pass_length}

            # Generate a password using '/dev/urandom'.
            # Call the 'tr' command to translate the password to a character set.
            password=$(LC_ALL=C tr -dc 'A-Za-z0-9!"#$%&'\''()*+,-./:;<=>?@[\]^_`{|}~' < /dev/urandom | dd ibs=1 obs=1 count="${pass_length}" 2> /dev/null) || :
            ;;
    esac

    # Write password to the 'password' file.
    if [[ -z ${password} ]]; then
        error_out "failed to save the password ${pass_name}" "1"
    fi

    printf '%s' "${password}" > "${configured_pass_location}/${pass_name}"
}

# Add a new password.
add() {
    # Ask for a name when no name was given using ${2}.
    set_name "${1}" "add"

    [[ -z "${pass_name}" ]] && error_out "failed to set a name" "1"

    # Check if a password with the chosen name already exists.
    # If it does, ask the user whether he wants to overwrite it,
    # or whether he wants to choose a different name.
    while [[ -f ${configured_pass_location}/${pass_name}.gpg ]]; do
        printf 'A password with the name %s already exists.' "'${pass_name}'"
        printf '\n'
        printf 'Do you want to overwrite the existing password [y/N]: '
        read -r overwrite

        case "${overwrite}" in
            [Yy])
                rm -rf "${configured_pass_location}/${pass_name}.gpg"
                ;;
            *)
                printf 'Enter a new name: '
                read -r pass_name
                ;;
        esac
    done

    # Ask if the user want to generate a random password.
    set_password

    # Encrypte the password file using gpg.
    gpg --encrypt --quiet --output "${configured_pass_location}/${pass_name}.gpg" \
        --recipient "${configured_key_id}" "${configured_pass_location}/${pass_name}"

    printf 'Password %s has been successfully saved' "'${pass_name}'"
    printf '\n'

    # Remove the Decrypted password file after reading
    # to prevent the password from being leaked afterwards.
    # ':?' to ensure this never expands to '/*'
    rm -rf "${configured_pass_location:?}/${pass_name}"
}

# update an existing password.
update() {
    # Ask for a name when no name was given using ${2}.
    set_name "${1}" "update"
    check_password_exists "${pass_name}"

    # Decrypte the password file.
    gpg --decrypt --quiet --output "${configured_pass_location}/${pass_name}" \
        "${configured_pass_location}/${pass_name}.gpg"

    # Ask if the user want to generate a random password.
    set_password

    # Remove the ecrypted password file to prevent gpg from asking to overwrite.
    rm -rf "${configured_pass_location:?}/${pass_name}.gpg"

    # Encrypte the password file using gpg.
    gpg --encrypt --quiet --output "${configured_pass_location}/${pass_name}.gpg" \
        --recipient "${configured_key_id}" "${configured_pass_location}/${pass_name}"

    printf 'Password %s has successfully been updated' "'${pass_name}'"
    printf '\n'

    # Remove the Decrypted password file after reading
    # to prevent the password from being leaked afterwards.
    # ':?' to ensure this never expands to '/*'
    rm -rf "${configured_pass_location:?}/${pass_name}"
}

# delete an existing password.
delete() {
    # Ask for a name when no name was given using ${2}.
    set_name "${1}" "delete"
    check_password_exists "${pass_name}"

    rm -rf "${configured_pass_location}/${pass_name}.gpg"
    printf 'Password %s has successfully been deleted' "'${pass_name}'"
    printf '\n'
}

# Print the password that was given.
show() {
    # Ask for a name when no name was given using ${2}.
    set_name "${1}" "show"
    check_password_exists "${pass_name}"

    # Decrypte the password file and show the password
    printf 'Password: %s' "$(gpg --decrypt --quiet "${configured_pass_location}/${pass_name}.gpg")"
    printf '\n'
}

# copy the password that was given to the clipboard.
# Clear the clipboard afterwards.
copy() {
    # Detect 'xclip' (X11), 'xsel' (X11) or 'wl-copy' (Wayland).
    if command -v xclip &> /dev/null; then
        clipboardCommand="xclip -selection clipboard"
    elif command -v xsel &> /dev/null; then
        clipboardCommand="xsel --clipboard"
    elif command -v wl-copy &> /dev/null; then
        clipboardCommand="wl-copy"
    else
        error_out "xclip, xsel, or wl-copy is required" 127
    fi

    # Ask for a name when no name was given using ${2}.
    set_name "${1}" "copy"
    check_password_exists "${pass_name}"

    # Ignore terminal interrupts (CTRL+C).
    trap '' INT

    # Decrypte the password file and copy it to the clipboard using xclip, xsel or wl-copy.
    # This WON'T show the password inside the terminal output.
    if gpg --decrypt --quiet "${configured_pass_location}/${pass_name}.gpg" | ${clipboardCommand}; then
        printf 'Password %s has been copied to the clipboard' "'${pass_name}'"
        printf '\n'
    else
        error_out "failed to copy password '${pass_name}' to the clipboard." 1
    fi

    # Wait for the timer to end clear the clipboard.
    # 'timer' can be changed in the config file.
    sleep "${configured_timer}" || kill 0

    if command -v xclip &> /dev/null; then
        xclip -selection clipboard < /dev/null
    elif command -v xsel &> /dev/null; then
        xsel --clipboard < /dev/null
    elif command -v wl-copy &> /dev/null; then
        wl-copy --clear
    fi

    printf 'Clipboard has been cleared to ensure it cannot be leaked.'
    printf '\n'
}

# Return a list of all the passwords that are stored on your machine.
list() {
    # Enable globbing for only this function.
    set +f

    # Print the list of all the passwords (without using the `ls` command).
    for p in "${configured_pass_location}"/*.gpg; do
        # Remove the path to the file.
        p="${p##*/}"

        # Remove the file extension.
        p="${p%%.gpg}"

        printf 'Name: %s' "${p}"
        printf '\n'
    done

    # Disable globbing.
    set -f
}

# Upload or download encrypted password(s) to/from a git repository.
# The user can chose whether he wants to locally host his git server or trust a
# third party like GitHub, eather way BashPass should work with both options.
# It's recommended to configure 'SSH' between the devices and the git server
# for optimal user experience.
sync() {
    # Detect 'git'
    has "git"

    [[ -z ${configured_git_repo} ]] && \
        error_out "URL to git repository not specified in config" "1"
    [[ -d "${configured_pass_location}/.git/" ]] || \
        error_out "${configured_pass_location} isn't a git repository" "1"

    # The '--git-dir' and '--work-tree' options allow the user to synchronize
    # their password(s) regardless of their current working directory (pwd).
    # See: https://stackoverflow.com/questions/7622616/executing-a-git-pull-from-a-different-directory
    case "${1}" in
        [Uu]pload)
            git --git-dir="${configured_pass_location}/.git/" \
                --work-tree="${configured_pass_location}" add .
            git --git-dir="${configured_pass_location}/.git/" \
                --work-tree="${configured_pass_location}" \
                commit -m "synchronize passwords ($(printf '%(%d/%m/%Y)T at %(%T)T)')"

            if git --git-dir="${configured_pass_location}/.git/" --work-tree="${configured_pass_location}" push; then
                printf '\n'
                printf 'Remote password(s) successfully synchronized with local.'
            else
                error_out "failed to upload password(s) to ${configured_git_repo}" "1"
            fi
            ;;
        [Dd]ownload)
            if git --git-dir="${configured_pass_location}/.git/" --work-tree="${configured_pass_location}" pull; then
                printf '\n'
                printf 'Local password(s) successfully synchronized with remote.'
            else
                error_out "failed to download password(s) from ${configured_git_repo}" "1"
            fi
            ;;
        *)
            error_out "unknown option '${1}'" "22"
            ;;
    esac

    printf '\n'
    printf 'Be aware you'\''ll need to import/export your GPG key.'
    printf '\n'
}

main() {
    # Detect the user.
    # When the user is root exit out.
    [[ "${UID}" == 0 ]] && error_out "permission denied" "13"

    # Create the necessary directories if they doesn't exists.
    mkdir -p "${configured_pass_location}"

    # Detect 'gpg'
    has "gpg"

    # Ask the GPG key ID to use for encrypting the password.
    # It will only ask when the configured_key_id isn't found in the config file.
    if [[ -z ${configured_key_id} ]]; then
        printf 'Enter the key ID of the GPG key you want to use: '
        read -r key_id
        printf 'keyID: %s\n' "${key_id}" >> "${config}"
    fi

    # Ask the e-email address to encrypt when it can't be found in the config file.
    if [[ -z ${configured_email} ]]; then
        printf 'Enter the email address you created the gpg key with: '
        read -r email
        printf 'email: %s\n' "${email}" >> "${config}"
    fi

    # Restrict new password file permissions to only the
    # current user.
    umask 077

    case "${1}" in
        "--help"| "-h") help;;
        "--version"| "-v") version;;
        "--add"| "-a") add "${2}";;
        "--update"| "-u") update "${2}";;
        "--delete"| "-d") delete "${2}";;
        "--show"| "-s") show "${2}";;
        "--copy"| "-c") copy "${2}";;
        "--list"| "-l") list;;
        "--sync"| "-S") sync "${2}" "${3}";;
        *) error_out "option '${1}' not found" "22";;
    esac
}

# Check if an argument '${1}' is given.
if [[ "${1}" ]]; then
    main "${@}"
else
    help
fi
