#!/usr/bin/env bash
# '-e' Abort the script when an error occures.
# '-f' To ensure that globbing is globally disabled.
# '+x' To ensure debug mode is never enabled (prevents the password from leaking).
# '-o pipefail' To ensure that the return code of a pipeline is the value of the last command to exit with a non-zero status.
#      Needed for the `copy` function.
set -e -f +x -o pipefail

# Assign the path to the config file to the variable '${config}'.
configLocation="$HOME/.config/bashpass"
config="$configLocation/bashpass.conf"

# Detect the config file.
if [[ ! -f ${config} ]]; then
    printf '\n'
    printf 'An error occurred: config file not found.'
    printf '\n'
    exit 2
fi

# Simple function to get the setting '${1}' from the config file.
# This basically replaces the '$(grep "setting" "$config" | cut -d" " -f2)'.
# It's also pure bash, which means that no sub shells are used.
get_setting() {
    while read -r;
    do
        if [[ "${REPLY}" =~ ^${1} ]]; then
            printf '%s' "${REPLY#*: }"
            break
        fi
    done < "${config}"
}

# Get the necessary configurations from the configuration file.
# '|| :' To prevent the script from exiting if the variable is not found (especially needed for the '${email} variable').
version="3.0" || :
email="$(get_setting 'email')" || :
key_id="$(get_setting 'keyID')" || :
pass_location="$HOME/$(get_setting 'location')" || :
timer="$(get_setting 'timer')" || :
pass_length="$(get_setting 'length')" || :
git_repo="$(get_setting 'gitRepo')" || :

# Print out the error that occurred and exit (with the correct exit code) afterwards.
kill() {
    printf '\n'
    printf 'An error occurred: %s' "${1}" >&2
    printf '\n'
    exit "${2}"
}

# Surprisingly, `sleep` is an external program and not a Bash built-in.
# So it is possible that it is not installed on a system, although it is very unlikely.
# We can use `read` to replace the `sleep` command.
sleep() {
    read -rt "${1}" <> <(:) || :
}

# Wrapper for `command -v` to avoid spamming '> /dev/null'.
# It also protects against user aliasses and functions.
has() {
    command=$(command -v "${1}") 2> /dev/null || kill "${1} is required" "127"
    [[ -x ${command} ]] || kill "${1} is not an executable" "1"
}

# Return all possible options/usages of BashPass.
help() {
    printf '%s' "\
BashPass version: ${version}
A password manager written in Bash.

bashpass [option] [name]                            - Basic command structure.

Options:
--help      or -h                                   - show this help message.
--version   or -v                                   - show the version number
--list      or -l                                   - list all password.
--add       or -a                            [name] - add a password.
--update    or -u                            [name] - update a password.
--delete    or -d                            [name] - delete a password.
--show      or -s                            [name] - show a password.
--copy      or -c                            [name] - copy a password to the clipboard.
--sync      or -S    [synchronize command]          - synchronize password(s) with a git repository.

synchronize command:
    upload           - Upload local password(s) to a remote repository.
    download         - Download password(s) from a remote repository.
"
}

# Return the current verion of BashPass.
version() {
    printf 'BashPass version: %s' "${version}"
    printf '\n'
}

# Function to ask for a name.
name() {
    name="${1}"
    function=${2}

    if [[ -z "${name}" ]]; then
        printf 'Enter the name of the password you want to %s: ' "${function}"
        read -r name
    fi
}

# Check whether the given password exists.
password_exists() {
    name="${1}"

    if [[ ! -f "${pass_location}/${name}.gpg" ]]; then
        kill "password '${name}' doesn't exist." "1"
    fi
}

# Ask the user whether to overwrite an existing password or not.
password_already_exists() {
    while [[ -f ${pass_location}/${name}.gpg ]]; do
        printf 'A password with the name %s already exists.' "'${name}'"
        printf '\n'
        printf 'Do you want to overwrite the existing password [y/N]: '
        read -r overwrite

        case "${overwrite}" in
            [Yy])
                rm -rf "${pass_location}/${name}.gpg"
                ;;
            *)
                printf 'Enter a new name: '
                read -r name
                ;;
        esac
    done
}

# Ask the user whether he would like to generate a password or to enter one himself.
random_password() {
    printf 'Do you want to generate a password [Y/n]: '
    read -r random

    case "${random}" in
        [Nn])
            printf 'Enter a password for %s: ' "${name}"
            read -rs password1
            printf '\n'

            [[ -z "${password1}" ]] && kill "the password cannot be empty." "1"

            printf 'Retype the password for %s: ' "${name}"
            read -rs password2
            printf '\n'

            while [[ "${password1}" != "${password2}" ]]; do
                printf 'Passwords didn'\''t match, please try again: '
                read -rs password2
                printf '\n'
            done

            password=${password1}
            ;;
        *)
            printf 'Give the length of the password (Default: %s): ' "${pass_length}"
            read -r length

            [[ -z ${length} ]] && length=${pass_length}

            # Generate a password using '/dev/urandom'.
            # Call the 'tr' command to translate the password to a character set.
            password=$(LC_ALL=C tr -dc 'A-Za-z0-9!"#$%&'\''()*+,-./:;<=>?@[\]^_`{|}~' < /dev/urandom | dd ibs=1 obs=1 count="${length}" 2> /dev/null) || :
            ;;
    esac

    # Write password to the 'password' file.
    if [[ -z ${password} ]]; then
        kill "failed to save the password ${name}" "1"
    fi

    printf '%s' "${password}" > "${pass_location}/${name}"
}

# add a new password.
add() {
    # Ask for a name when no name was given using ${2}.
    name "${1}" "add"

    [[ -z "${name}" ]] && kill "failed to set a name" "1"

    # Check if a password with the chosen name already exists.
    password_already_exists

    # Ask if the user want to generate a random password.
    random_password

    # Encrypte the password file using gpg.
    gpg --encrypt --quiet --output "${pass_location}/${name}.gpg" --recipient "${key_id}" "${pass_location}/${name}"

    printf 'Password %s has been successfully saved' "'${name}'"
    printf '\n'

    # Remove the Decrypted password file after reading
    # to prevent the password from being leaked afterwards.
    # ':?' to ensure this never expands to '/*'
    rm -rf "${pass_location:?}/${name}"
}

# update an existing password.
update() {
    # Ask for a name when no name was given using ${2}.
    name "${1}" "update"
    password_exists "${name}"

    # Decrypte the password file.
    gpg --decrypt --quiet --output "${pass_location}/${name}" "${pass_location}/${name}.gpg"

    # Ask if the user want to generate a random password.
    random_password

    # Remove the ecrypted password file to prevent gpg from asking to overwrite.
    rm -rf "${pass_location:?}/${name}.gpg"

    # Encrypte the password file using gpg.
    gpg --encrypt --quiet --output "${pass_location}/${name}.gpg" --recipient "${key_id}" "${pass_location}/${name}"

    printf 'Password %s has successfully been updated' "'${name}'"
    printf '\n'

    # Remove the Decrypted password file after reading
    # to prevent the password from being leaked afterwards.
    # ':?' to ensure this never expands to '/*'
    rm -rf "${pass_location:?}/${name}"
}

# delete an existing password.
delete() {
    # Ask for a name when no name was given using ${2}.
    name "${1}" "delete"
    password_exists "${name}"

    rm -rf "${pass_location}/${name}.gpg"
    printf 'Password %s has successfully been deleted' "'${name}'"
    printf '\n'
}

# Print the password that was given.
show() {
    # Ask for a name when no name was given using ${2}.
    name "${1}" "show"
    password_exists "${name}"

    # Decrypte the password file and show the password
    printf 'Password: %s' "$(gpg --decrypt --quiet "${pass_location}/${name}.gpg")"
    printf '\n'
}

# copy the password that was given to the clipboard.
# Clear the clipboard afterwards.
copy() {
    # Detect 'xclip' (X11), 'xsel' (X11) or 'wl-copy' (Wayland).
    if command -v xclip &> /dev/null; then
        clipboardCommand="xclip -selection clipboard"
    elif command -v xsel &> /dev/null; then
        clipboardCommand="xsel --clipboard"
    elif command -v wl-copy &> /dev/null; then
        clipboardCommand="wl-copy"
    else
        kill "xclip, xsel, or wl-copy is required" 127
    fi

    # Ask for a name when no name was given using ${2}.
    name "${1}" "copy"
    password_exists "${name}"

    # Ignore terminal interrupts (CTRL+C).
    trap '' INT

    # Decrypte the password file and copy it to the clipboard using xclip, xsel or wl-copy.
    # This WON'T show the password inside the terminal output.
    if gpg --decrypt --quiet "${pass_location}/${name}.gpg" | ${clipboardCommand}; then
        printf 'Password %s has been copied to the clipboard' "'${name}'"
        printf '\n'
    else
        kill "failed to copy password '${name}' to the clipboard." 1
    fi

    # Wait for the timer to end clear the clipboard.
    # 'timer' can be changed in the config file.
    sleep "${timer}" || kill 0

    if command -v xclip &> /dev/null; then
        xclip -selection clipboard < /dev/null
    elif command -v xsel &> /dev/null; then
        xsel --clipboard < /dev/null
    elif command -v wl-copy &> /dev/null; then
        wl-copy --clear
    fi

    printf 'Clipboard has been cleared to ensure it cannot be leaked.'
    printf '\n'
}

# Return a list of all the passwords that are stored on your machine.
list() {
    # Enable globbing for only this function.
    set +f

    # Print the list of all the passwords (without using the `ls` command).
    for p in "${pass_location}"/*.gpg; do
        # Remove the path to the file.
        p="${p##*/}"

        # Remove the file extension.
        p="${p%%.gpg}"

        printf 'Name: %s' "${p}"
        printf '\n'
    done

    # Disable globbing.
    set -f
}

# Upload or download encrypted password(s) to/from a git repository.
# The user can chose whether he wants to locally host his git server or trust a
# third party like GitHub, eather way BashPass should work with both options.
# It's recommended to configure 'SSH' between the devices and the git server for optimal user experience.
sync() {
    # Detect 'git'
    has "git"

    [[ -z ${git_repo} ]] && kill "URL to git repository not specified in config" "1"
    [[ -d "${pass_location}/.git/" ]] || kill "${pass_location} isn't a git repository" "1"

    # The '--git-dir' and '--work-tree' options allow the user to synchronize
    # their password(s) regardless of their current working directory (pwd).
    # See: https://stackoverflow.com/questions/7622616/executing-a-git-pull-from-a-different-directory
    case "${1}" in
        [Uu]pload)
            git --git-dir="${pass_location}/.git/" --work-tree="${pass_location}" add .
            git --git-dir="${pass_location}/.git/" --work-tree="${pass_location}" commit -m "synchronize passwords ($(printf '%(%d/%m/%Y)T at %(%T)T)')"
            if git --git-dir="${pass_location}/.git/" --work-tree="${pass_location}" push; then
                printf '\n'
                printf 'Remote password(s) successfully synchronized with local.'
            else
                kill "failed to upload password(s) to ${git_repo}" "1"
            fi
            ;;
        [Dd]ownload)
            if git --git-dir="${pass_location}/.git/" --work-tree="${pass_location}" pull; then
                printf '\n'
                printf 'Local password(s) successfully synchronized with remote.'
            else
                kill "failed to download password(s) from ${git_repo}" "1"
            fi
            ;;
        *)
            kill "unknown option '${1}'" "22"
            ;;
    esac

    printf '\n'
    printf 'Be aware you'\''ll need to import/export your GPG key.'
    printf '\n'
}

main() {
    # Detect the user.
    # When the user is root exit out.
    [[ "$UID" == 0 ]] && kill "permission denied" "13"

    # Create the necessary directories if they doesn't exists.
    mkdir -p "${pass_location}"

    # Detect 'gpg'
    has "gpg"

    # Ask the GPG key ID to use for encrypting the password.
    # It will only ask when the key_id isn't found in the config file.
    if [[ -z ${key_id} ]]; then
        printf 'Enter the key ID of the GPG key you want to use: '
        read -r key_id
        printf 'key_id: %s\n' "${key_id}" >> "${config}"
    fi

    # Ask the e-email address to encrypt when it can't be found in the config file.
    if [[ -z ${email} ]]; then
        printf 'Enter the email address you created the gpg key with: '
        read -r email
        printf 'email: %s\n' "${email}" >> "${config}"
    fi

    case "${1}" in
        "--help"| "-h") help;;
        "--version"| "-v") version;;
        "--add"| "-a") add "${2}";;
        "--update"| "-u") update "${2}";;
        "--delete"| "-d") delete "${2}";;
        "--show"| "-s") show "${2}";;
        "--copy"| "-c") copy "${2}";;
        "--list"| "-l") list;;
        "--sync"| "-S") sync "${2}" "${3}";;
        *) kill "option '${1}' not found" "22";;
    esac
}

# Check if an argument '${1}' is given.
if [[ "${1}" ]]; then
    main "${@}"
else
    help
fi
