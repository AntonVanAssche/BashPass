#!/bin/bash

# '-e' Abort the script when an error occures.
# '-f' To ensure that globbing is globally disabled.
# '+x' To ensure debug mode is never enabled (prevents the password from leaking).
set -ef +x

# Detect the user.
# When the user is root exit out.
if [[ "$UID" == 0 ]]; then
   printf "You must run this as a normal user.\nCurrent user ID: %s %s\n" "${UID}" "$([[ "${UID}" -eq 0 ]] && printf "(root)")"
   exit 1
fi

# Get the necessary configurations from the configuration file.
configLocation="$HOME/.config/bashpass"
config="$configLocation/bashpass.conf"
email="$(grep "email" "$config" | cut -d" " -f2)"
passLocation="$HOME/$(grep "location" "$config" | cut -d" " -f2)"
version="$(grep "version" "$config" | cut -d" " -f2)"
timer="$(grep "timer" "$config" | cut -d" " -f2)"
passLength="$(grep "length" "$config" | cut -d" " -f2)"

# Create the necessary directories/files if they doesn't exists
mkdir -p "${passLocation}" "${configLocation}"
touch "${config}"

Help() {
   cat << EOF
BashPass version: ${version}
A simple password manager written in Bash.

bashpass [option] [name]                      - Basic command structure.

Options:
--help       or -h                            - Show this help message.
--version    or -v                            - Show the version number
--add        or -a                     [name] - Add a password.
--update     or -u                     [name] - Update a password.
--delete     or -d                     [name] - Delete a password.
--show       or -s                     [name] - Show a password.
--copy       or -c                     [name] - Copy a password to the clipboard.
--list       or -l                            - List all password.
--sync       or -S                     [name] - Synchronize a password with a other device on your local network.
EOF
}

Version() {
   printf "BashPass version: %s" "${version}"
}

RandomPassword() {
   printf "Do you want to generate a password [Y/n]: "
   read -r random

   case "${random}" in
      [Nn])
         printf "Enter a password: "
         read -rs password1
         printf "\n"

         printf "Enter the password again: "
         read -rs password2
         printf "\n"
         
         while [[ "${password1}" != "${password2}" ]]; do
            printf "Passwords ditn't match, please try again: "
            read -rs password2
            printf "\n"
         done

         password=${password1}
         ;;
      *)
         printf "Give the length of the password (Default: 14): "
         read -r length

         if [[ -z ${length} ]]; then
            length=${passLength}
         fi

         # Generate a password using '/dev/urandom'.
         # Call the 'tr' command to translate the password to a character set.
         password=$(</dev/urandom tr -dc '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%*()?.,/+-abcdefghijklmnopqrstuvwxyz' | head -c "${length}"; echo "")
         ;;
   esac

   [[ -z "$password" ]] && Kill "Failed to set a password"

   # Write password to the 'password' file.
   printf "%s" "${password}" > "${passLocation}/${name}"
}

# Function to ask for a name.
Name() {
   name="${1}"
   function=${2}

   if [[ -z "${name}" ]]; then
      printf "Enter the name of the password you want to %s: " "${function}"
      read -r name
   fi
}

# Function to print out errors and exit afterwards.
Kill() {
   printf "A error occured: %s" "${1}"
   printf "\n"
   Help
   printf "\n"
   exit 1
}

PasswordExists() {
   while [[ -f ${passLocation}/${name}.gpg ]]; do
      printf "A password with the name %s already exists." "'${name}'"
      printf "\n"
      printf "Do you want to overwrite the existing password [y/N]: "
      read -r overwrite
      
      case "${overwrite}" in
         [Yy])
            rm -rf "${passLocation}/${name}.gpg"
            ;;
         *)
            printf "Enter a new name: "
            read -r name
            ;;
      esac
   done
}

GetLatestVersion() {
   curl --silent "https://api.github.com/repos/AntonVanAssche/BashPass/releases/latest" | # Get latest release from GitHub api
   grep '"tag_name":' |                                            # Get tag line
   sed -E 's/.*"([^"]+)".*/\1/'                                    # Pluck JSON value
}

Add() {
   # Ask for a name when no name was given using ${2}.
   Name "${1}" "add"

   [[ -z "${name}" ]] && Kill "Failed to set a name"

   # Check if a password with the chosen name already exists.
   PasswordExists

   # Ask if the user want to generate a random password.
   RandomPassword

   # Encrypte the password file using gpg.
   gpg --encrypt --output "${passLocation}/${name}.gpg" --recipient "${email}" "${passLocation}/${name}"  &> /dev/null

   printf "Password %s has been successfully saved" "'${name}'"
   printf "\n"

   # Remove the Decrypted password file after reading
   # to prevent the password from being leaked afterwards.
   # ':?' to ensure this never expands to '/*'
   rm -rf "${passLocation:?}/${name}"
}

Update() {
   # Ask for a name when no name was given using ${2}.
   Name "${1}" "update"

   # Decrypte the password file.
   gpg --decrypt --output "${passLocation}/${name}" "${passLocation}/${name}.gpg" &> /dev/null

   # Ask if the user want to generate a random password.
   RandomPassword

   # Remove the ecrypted password file to prevent gpg from asking to overwrite.
   rm -rf "${passLocation:?}/${name}.gpg"

   # Encrypte the password file using gpg.
   gpg --encrypt --output "${passLocation}/${name}.gpg" --recipient "${email}" "${passLocation}/${name}"  &> /dev/null

   printf "Password %s has successfully been updated" "'${name}'"
   printf "\n"

   # Remove the Decrypted password file after reading
   # to prevent the password from being leaked afterwards.
   # ':?' to ensure this never expands to '/*'
   rm -rf "${passLocation:?}/${name}"
}

Delete() {
   # Ask for a name when no name was given using ${2}.
   Name "${1}" "delete"

   rm -rf "${passLocation}/${name}.gpg"
   printf "Password %s has successfully been deleted" "'${name}'"
   printf "\n"
}

Show() {
   # Ask for a name when no name was given using ${2}.
   Name "${1}" "show"

   # Decrypte the password file and show the password
   printf "Password: %s" "$(gpg -dq "${passLocation}/${name}.gpg")"
   printf "\n"
}

Copy() {
   # Detect 'xclip'
   command -v xclip &> /dev/null || Kill "xclip is required"
   # Ask for a name when no name was given using ${2}.
   Name "${1}" "copy"

   # Decrypte the password file and copy it to the clipboard using xclip.
   # This WON'T show the password inside the terminal output.
   printf "%s" "$(gpg -dq "${passLocation}/${name}.gpg")" | xclip -selection clipboard
   
   # Wait for the timer to end clear the clipboard.
   # 'timer' can be changed in the config file.
   sleep "${timer}" || kill 0
   xclip -selection clipboard < /dev/null
}

List() {
   ls -1 "${passLocation}"
   printf "\n"
}

Sync() {
   # Detect 'ssh' and 'scp'
   command -v ssh &> /dev/null || Kill "ssh is required"
   command -v scp &> /dev/null || Kill "scp is required"

   Name "${1}" "synchronize"

   printf "Enter the username of the user on the other device: "
   read -r username
   printf "Enter the local IP address of the other device: "
   read -r localIP
   
   scp "${passLocation}/${name}.gpg" "${username}"@"${localIP}":~/.local/share/bashpass/

   printf "\n"
   printf "Be aware you'll need to import your GPG key on the other device as well."
   printf "\n"
   printf "Do you want to do this now [Y/n]? "
   read -r keyExport

   case "${keyExport}" in
      [Nn])
         printf "You will have to manually export your keys to the other device if you haven't done so."
         ;;
      *)
         gpg --list-keys
         printf "Enter your key ID (Example: VEB8K7W2O3OOOBEREODILJ4DH046253LB68CXK21): "
         read -r keyID

         gpg --armor --export "${keyID}" | ssh "${username}"@"${localIP}" gpg --batch --import - || printf "Failed to import the public key."
         gpg --armor --export-secret-key "${keyID}" | ssh "${username}"@"${localIP}" gpg --batch --allow-secret-key-import --import - || printf "Failed to import the private key."
         ;;   
   esac
}

# Detect 'gpg'
command -v gpg &> /dev/null || Kill "gpg is required"

# Ask the e-meil address to encrypt when it can't be found in the config file.
if [[ -z ${email} ]]; then
   printf "Enter the email address you created the gpg key with: "
   read -r email
   printf "email: %s" "${email}" >> "${config}"
fi

function Main() {
   [[ "$(GetLatestVersion)" == "${version}" ]] || printf "There is a new version available\n"

   case "$1" in
      "--help"| "-h") Help;;
      "--version"| "-v") Version;;
      "--add"| "-a") Add "${2}";;
      "--update"| "-u") Update "${2}";;
      "--delete"| "-d") Delete "${2}";;
      "--show"| "-s") Show "${2}";;
      "--copy"| "-c") Copy "${2}";;
      "--list"| "-l") List;;
      "--sync"| "-S") Sync "${2}";;
      *) Kill "option '${1}' not found";;
   esac
}

# Check if an argument '$1' is given.
if [[ "$1" ]]; then
   Main "$@"
else
   Help
fi
